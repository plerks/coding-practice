### 滚动数组优化dp空间使用

dp空间优化的一个技巧，在`AcWing292. 炮兵阵地`中必须使用才能不超内存。

当dp计算的过程只需要相邻的数行时(例如计算dp[i][]只需dp[i - 1][]和dp[i - 2][])，可以使用滚动数组优化空间使用。(不使用滚动数组的话，可以定义3个数组，在计算完成后交换指针，维持dp0为最新行，dp1为上一行，dp2为上上行。)

以`AcWing292. 炮兵阵地`中的空间优化为例，dp数组是个三维数组dp[x][y][z]。而dp[i]的状态只与dp[i - 1]有关，于是可以用两行的滚动数组优化dp数组，以下以dpFull记优化前的数组，dp记优化后的数组。

用滚动数组替换dpFull，dp时只涉及到本行与上一行，
因此滚动数组只需要2行即可。

dpFull[0]没有前面的行dpFull[-1]，计算时dpFull[-1]等价于全0，刚好可以用滚动数组初始值为全0取代(相当于[-2, -1]也铺了个数组)，不用特判计算边界条件。

滚动数组行数为w，相当于用行数为w的窗口平移铺满行数为m - 1的dpFull，dpFull[i]对应的dp[]行号为dp[i % w]。
注意当还没计算完第一个窗口时，计算dpFull[i]时，依赖的上面的行依次是dp[(i - 1) % w], dp[(i - 2) % w], ... dp[(i - k) % w] (1 <= k < w)，注意i - k可能为负数，所以需要写成(i - k + w) % w，也可以单独处理dpFull的前w行，相当于先特判把初始的窗口算出来，这样就不涉及i - k可能为负数。

`AcWing292. 炮兵阵地`由于窗口w大小为2，为2的幂次，$x \% 2^n$等价于$x \& (2^n - 1)$，所以可以直接用位运算求i在dp中对应的行号，这里即使$i - k$可能为负，用$\& (2^n - 1)$也不会有问题，原因在于：
$0 \geq i - k > -2^n$，则$0 \leq -(i - k) < 2^n$，则$-(i - k)$包含第n位往上一定全为0，则lowbit在$[0, n - 1]$位，$(i - k)$相对$-(i - k)$，lowbit之上的高位全相反，则$i - k$包含第n位往上一定全为1，则$i - k + 2^n$的效果是把$i - k$第n位往上全变为0，则$(i - k + 2^n) \% 2^n$与$(i - k) \& (2^n - 1)$相等。

### 总结
将dpFull用滚动数组dp优化，dp的行数$w$取决于dpFull计算过程中计算某一行时需要用到前几行。

对dpFull的计算等价到dp的计算，dpFull的第i行相应为dp[i % w]，i上面的行相应为dp[(i - k) % w]。由于在开头的$[0, w - 1)$行，依赖的前面行可能出现$i - k$为负数的情况，递推时需要写成$dp[(i - k + w) \% w]$。

$dp[(i - k + w) \% w]$能保证下标不越界，但是对开头的几行，$dp[(i - k + w) \% w]$不一定等价指向$dpFull$中负下标行，可能需要特判，若$dp$的初始值能等价于$dpFull$中负下标行则不用特判，或者看能否等价于在$dpFull$的负下标位置再放一个初始值窗口。

若拿不准的话则可以特判计算第一个窗口，则$dp[(i - k + w) \% w]$一定不越界且指向$dpFull$中的有效行。

若$w$为2的幂次，则$dp[(i - k + w) \% w]$等价于$dp[(i - k) \& (w - 1)]$