## 树状数组
在LeetCode307. 区域和检索 - 数组可修改中第一次遇到树状数组，不过当时只看了个大概，没把拆分区间的技巧和性质完全搞明白，oi wiki上上来就先把拆分后的树状数组结构摆出来了，很难理解是怎么来的。学了线段树后，再结合灵茶山艾府的视频讲解和题解搞明白了。

两道板子题:

* LeetCode307. 区域和检索 - 数组可修改

* 洛谷P3374 【模板】树状数组 1

参考:

* https://www.bilibili.com/video/BV14r421W7oR/

* https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/

* https://oi-wiki.org/ds/fenwick/

考虑LeetCode307. 区域和检索 - 数组可修改的 单点修改 + 区间求和 的场景，对于一个长度为n的数组nums[0...n-1]，要对nums进行单点修改和区间求和。最直接的办法，直接模拟，单点修改要O(1)时间，区间求和要O(n)时间。如果用前缀和，那么区间求和可以缩短到O(1)时间，但是单点修改时由于要更新前缀和数组，因此又需要O(n)时间。因此使用前缀和没有实质性的变化。

能不能平衡单点修改和区间求和的开销？

树状数组和线段树都使用了类似的思路，将区间拆分，并树化，这样单点修改和区间求和都只需要O(logn)时间。

树状数组使用了lowbit将前缀区间划分为关键区间，而线段树则是二分区间，分出子节点。

树状数组的功能被线段树包含，树状数组能做的，线段树一定能做，反之则不然。但是树状数组的代码量小，不过树状数组的结构技巧性很强。

### 拆分

先来看对于nums[0...7]，树状数组如何拆分前缀区间（由于要用lowbit，所以树状数组内部记录的时候下标要从1开始，nums[0...7]对应的下标范围是[1...8]）

以7为例，7 = 0b111 = 4 + 2 + 1，对于区间[1, 7]，从右往左有3个1，第一个lowbit为1，从右端点往左1个数，拆出[7, 7]，剩下[1, 6]，区间右端点现在是0b110，再拆，拆出[5, 6]，区间变为[1, 4]，最后一个lowbit为4，再拆拆出[1, 4]，结束。

因此[1, 7] = [1, 4] + [5, 6] + [7, 7]

[1, 1]到[1, 8]拆分为以下这样:

```
[1, 1] = [1, 1]                     (1 = 1)
[1, 2] = [1, 2]                     (2 = 2)
[1, 3] = [1, 2] + [3, 3]            (3 = 2 + 1)
[1, 4] = [1, 4]                     (4 = 4)
[1, 5] = [1, 4] + [5, 5]            (5 = 4 + 1)
[1, 6] = [1, 4] + [5, 6]            (6 = 4 + 2)
[1, 7] = [1, 4] + [5, 6] + [7, 7]   (7 = 4 + 2 + 1)
[1, 8] = [1, 8]                     (8 = 8)
```
[1, i]拆出的区间的数量等于i的二进制1的数量。

**性质： 对于[1, 1], [1, 2], ..., [1, n]，拆出的互不相同的区间刚好是n个**

证明：

对于区间[1, i]，其拆出的第一个(用最低位的1拆出的)区间 **[i - lowbit(i) + 1, i]**，称之为**关键区间**。关键区间一共有n个，因为[1, 1], [1, 2], ..., [1, n]拆出的关键区间的**右端点**分别是1 ~ n，互不相同。

下证拆出的所有区间都是这n个关键区间。

归纳证明

对[1, 1]，成立。

假设当i <= k - 1时成立，对 i = k：

[1, k]拆出的关键区间是[k - lowbit(k) + 1, k]，然后剩余的部分是[1, k - lowbit(k)]，这是前面的区间，由归纳假设，成立。

因此，重要的是 **[i - lowbit(i) + 1, i]** 这n个**关键区间**，**任意前缀区间可由这n个关键区间不相交并出**(这是树状数组区间求和的核心，单点修改的核心应该在于关键区间的包含性质)。

于是，我们用tree数组维护这n个关键区间的和，tree[i]对应右端点为i的关键区间的和，后续的单点修改和区间求和，用这n个关键区间的和实现。

### 区间求和
对于区间求和nums[L, R]，可以将之转化为前缀求和之差，即在树状数组里求[1, R + 1] - [1, L]，注意树状数组下标要对应加1。

树状数组如何求前缀和[1, i]?

转化为关键区间！上面已经证明了，任意[1, i]可以拆分为不相交关键区间的并，于是只需借助lowbit，不断地拆分出关键区间，然后用关键区间的和累加即可求出前缀和。

### 单点修改
对于修改nums[i - 1]处的元素，我们维护的关键区间[i - lowbit(i) + 1, i]之和需要修改，这是第一个要修改的，右端点小于i的关键区间不包含nums[i - 1]，不需修改，还有哪些关键区间要修改？

**性质1：右端点为x的关键区间，被右端点为x+lowbit(x)的关键区间真包含**

**性质2：右端点在[x+1, x+lowbit(x)−1]内的关键区间，与右端点为x的关键区间没有任何交集**

先证性质1，只需证明右端点为x+lowbit(x)的关键区间的左端点 <= 右端点为x的关键区间的左端点，然后由于右端点不同，一定是真包含。

记 $y = x + lowbit(x)$，则只需证

$y - lowbit(y) + 1 \le x - lowbit(x) + 1$

即

$y - lowbit(y) \le x - lowbit(x)$

设 $x = m \cdot 2^{k+1} + 2^k$，则 $lowbit(x) = 2^k$，$x - lowbit(x) = m \cdot 2^{k+1}$

而 $y = (m + 1) \cdot 2^{k+1}$，则有

$lowbit(y) \ge 2^{k+1}$

于是

$y - lowbit(y) \le m \cdot 2^{k+1}$

性质1成立。

再证性质2，

设 $y = x + b$，其中 $1 \le b < 2^k$，右端点为y的关键区间的左端点为 $y - lowbit(y) + 1$，只需证明 $y - lowbit(y) + 1 > x$

$y = x + b = (m + 1) \cdot 2^{k+1} + b$

由于 $1 \le b < 2^k$，所以 $lowbit(y)$ 在b的部分，所以 $lowbit(y) = lowbit(b)$，又由于 $b - lowbit(b) \ge 0$，则

$y - lowbit(y) + 1 = x + b - lowbit(b) + 1 \ge x + 1 > x$

性质2成立。

[oi wiki](https://oi-wiki.org/ds/fenwick/)上还提到了一个性质，

**性质3：对于右端点x < y，要么x和y的关键区间不交，要么x的关键区间真包含于y的关键区间**

这可以通过上面两条性质证明，右端点x, x + lowbit(x), ...相当于隔板，若y就是这些隔板，则由性质1可推真包含，若y在隔板中间，则由性质2，y与左边最近的隔板无交，由性质1，x是这个隔板的子集，从而y与x无交。

也可以直接证，若关键区间x与关键区间y有交，则有 $y - lowbit(y) + 1 \le x < y$，只需证明 $y - lowbit(y) + 1 \le x - lowbit(x) + 1$

设 $y = m \cdot 2^{k+1} + 2^k$，则 $lowbit(y) = 2^k$，则 $x = m \cdot 2^{k+1} + b$，其中 $1 \le b < 2^k$。

于是 $x - lowbit(x) = m \cdot 2^{k+1} + b - lowbit(b) \ge m \cdot 2^{k+1} = y - lowbit(y)$

所以 $y - lowbit(y) + 1 \le x - lowbit(x) + 1$，性质3成立。

回到我们需要修改哪些关键区间之和的问题，由上面的性质，我们只需修改tree[i], tree[i + lowbit(i)], tree[(i + lowbit(i)) + lowbit(i + lowbit(i))], ...的值(tree[i]表示右端点为i的关键区间的和)，将其加上diff即可。

也就是，一层层往上，找包含nums[i - 1]的关键区间并做修改。

### 建树
O(n)时间即可建树，从左到右遍历tree[i]，直接将nums[i - 1]加进tree[i]即可求出tree[i]（前面的部分已在前面的循环中加了），然后将tree[i]加到tree[i + lowbit(i)]即可(子节点贡献到父节点)。

[oi wiki](https://oi-wiki.org/ds/fenwick/#thetan-%E5%BB%BA%E6%A0%91)上还有个O(n)建树的方法，先预处理出nums的前缀和，然后求tree[i]时直接用前缀和求出[i - lowbit(i) + 1, i]的和即可。

### 时间复杂度
树高为log(n)，n为需要管理的数组的长度。因为[1, i]分出的关键区间的数目等于i的二进制1的数目，这是log(n)级别的，所以树高也是log(n)级别的。

建树: O(n)

单点修改: O(logn)

区间求和: O(logn)

### 特殊树状数组
树状数组本来是没有 单点修改 + 区间求max 的类型的，单点修改之后，考虑对应的关键区间，之前记了这个关键区间的最大值，但是现在单点修改了，不知道改的是哪里，有可能把原先最大值的位置改了，于是求关键区间最大值就需要遍历对应区间，于是时间复杂度就得O(n)了。且区间求max无法分解为两个前缀求max的运算，就算考虑 单点修改 + 前缀求max 的树状数组，也仍然有时间复杂度过高的问题。

但是`LeetCode3161. 物块放置查询`中有一个特殊场景，单点修改只会把值改大，这样一来只需与旧的最大值比较就可以知道现在关键区间的最大值，于是这种场景下就可以有 单点修改 + 前缀求max 类型的树状数组，具体见[灵茶山艾府题解解法二](https://leetcode.cn/problems/block-placement-queries/solutions/2790395/ping-heng-shu-xian-duan-shu-pythonjavacg-8klz/)。

### 差分树状数组

在 LeetCode3841. 查询树上回文路径 中碰到这个技巧，借助差分的思想让树状数组完成 区间add + 单点查询，用线段树也可以做到，所以不用特别在意这个，技巧为：

目的是要完成 区间add + 单点查询 的功能，而树状数组的功能是 单点修改 + 区间求和，把区间add用差分的思想来完成，只需要标记开始和结束位置的变化量，区间add变成了两个单点修改，同时单点查询变成了对差分数组的前缀和，于是用差分树状数组也可以完成 区间add + 单点查询 的功能。

差分树状数组关注的是差分数组，区间add经过差分数组变成了两个单点修改，单点查询经过差分数组变成了前缀求和。

### 双树状数组

树状数组也能够完成 区间add + 区间求和 ，对于区间add，同样，借助差分数组 B1，可以把区间add变成两个单点修改，可是区间求和要怎么办？

再记录一个数组，只有差分数组 B1 无法求区间和，例如修改 [2, 3] 区间，B1 = [0, 0, +5, 0, -5, 0] ，对 B1 求 sum([1, 3]) 不是原始数组 nums 的区间和，因为 +5 该被加两次。还需要一个辅助的 B2 = [0, 0, +5 * (l - 1), 0, -5 * r, 0] = [0, 0, +5, 0, -20, 0]。sum1([2, 3]) = 5，sum2([2, 3]) = 5，prefix_sum(3) = 5 * 3 - 5 = 10 ，这样就是对的。

主要关键点在 sum1 * x - sum2 这个数学关系，对于 add(l, r, val) 后的求 prefix_sum(index)，sum1 * x - sum2

1. 对于求 index < l 的前缀和，结果会是 0

2. 对于求 l <= index < r 的前缀和，sum1 * x 的效果是视作 [1, r] 都 add 了 val ，这显然多了，所以要用 减 val * (l - 1) 抵消掉前面部分

3. 对于求 index >= r 的前缀和，sum1 会是 0，会由 sum2 算出来区间和

最后 sum1 * x - sum2 这个技巧会符合：做一次 range_add(l, r, val)，对 prefix_sum(x) 的影响是：

$$
f(x)=
\begin{cases}
0 & x < l \\
val \cdot (x - l + 1) & l \le x \le r \\
val \cdot (r - l + 1) & x > r
\end{cases}
$$


以上是对一次区间add的分析，但是由于多次的区间add会有可加性，发生多次修改后的求前缀和可以看作多个这样的过程加起来，结果不会错。

代码为:

```cpp
void range_add(int l, int r, long long val) {
    add(B1, l, val);
    add(B1, r + 1, -val);
    add(B2, l, val * (l - 1));
    add(B2, r + 1, -val * r);
}

long long prefix_sum(int x) {
    long long sum1 = 0, sum2 = 0;
    for (int i = x; i > 0; i -= i & -i) {
        sum1 += B1[i];
        sum2 += B2[i];
    }
    return sum1 * x - sum2;
}
```