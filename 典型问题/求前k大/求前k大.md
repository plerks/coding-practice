相关题目: [LeetCode2342. 数位和相等数对的最大和](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/)

## 从n个元素中求前k个最大的元素(k < n)
直接的做法是将n个元素组织成一个大顶堆，然后poll() k次，得到的k个元素即为最大的k个元素。

但是当n >> k时，堆占用的空间会比较大，可以优化空间使用。

具体做法是建立一个**小顶堆**，遍历n个元素，

1. 若堆的size还小于k，则直接将nums[i]入堆。

2. 若堆的size == k，则将nums[i]与堆顶元素比较。若nums[i] < 堆顶元素，则堆中的k个元素都比nums[i]大，nums[i]一定不是前k大，直接忽略nums[i]；若nums[i] >= 堆顶元素，则堆顶元素一定不是前k大，此时nums[i]和堆中剩余的k - 1个元素为当前遍历到的元素中的前k大，则删除堆顶元素并将nums[i]入堆。（nums[i] == 堆顶元素放哪种情况都可）

最终堆中的元素即为前k大。

这样的做法，堆中不需要保存所有的n个元素。

上述堆的使用也可换成降序数组：若数组已有元素个数小于k，则直接将nums[i]加入数组末尾，再用插入排序的办法找到nums[i]的正确位置。若数组已有元素个数等于k，若arr[k - 1] >= nums[i]，则直接忽略nums[i]；若arr[k - 1] < nums[i]，则arr[k - 1] = nums[i]并将nums[i]用插入排序的办法找到正确位置。可以直接将数组元素全部初始化为Integer.MIN_VALUE，省去记录数组中已有元素个数的麻烦。

## 从n个元素中求前k个最小的元素(k < n)
对称情况，使用一个**大顶堆**。