## 线段树
将数组二分，树化，从而实现区间修改和区间求和都是logn的时间复杂度。

线段树的能力覆盖了树状数组，树状数组能完成的，线段树都能完成。

以区间add + 区间求和为例，大致总结下，很多内容注释在了`区间add + 区间求和/SegTreeRangeAddRangeSum.cpp`里。

### 区间查询
从根节点开始，根据当前节点所管辖的范围，递归求解。

当前区间的tree值是结合了懒惰标记的，是最新的。

若当前节点是查询区间的子集时则不需要再递归下去，直接用当前节点的信息返回即可。

若当前节点存在懒惰标记且需要递归子节点时，需要先将懒惰标记下放(pushdown)，将子节点的tree值和lazy值更新为最新(注意更新子节点lazy值时子节点可能已有lazy值)，然后才能递归子节点。

### 区间修改
同样，从根节点开始，根据当前节点所管辖的范围，递归求解。

当前区间的tree值是结合了懒惰标记的，是最新的。

若当前区间是查询区间的子集时则不需要再递归下去，更新当前节点后打好懒惰标记以备后面更新子节点，然后返回即可。

若当前节点存在懒惰标记且需要递归子节点时，需要先将懒惰标记下放(pushdown)，将子节点的tree值和lazy值更新为最新(注意更新子节点lazy值时子节点可能已有lazy值)，然后才能递归子节点，子节点递归完成后，由于子节点进行了修改，所以需要从子节点更新当前节点(pushup)。

### 时间复杂度
详细分析见`区间add + 区间求和/SegTreeRangeAddRangeSum.cpp`里的注释。

树高为O(logn)，节点规模为O(n)

建树: O(n)

区间修改: O(logn)

区间查询: O(logn)