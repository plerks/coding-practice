### 给定障碍点数组obstacles，对于点(x, y)，如何判断(x, y)是否为障碍点？（涉及的点的横纵坐标都>=0）
直接的做法是对每个障碍点构造一个Point对象，重写Point类的equals()和hashCode()方法，然后将障碍点放入HashSet中，然后判断set是否包含new Point(x, y)。但是若点的取值范围有限，可以不用创建Point对象：
```Java
public class BaseFormToCheckRepeat {
    public static void main(String[] args) {
        int x = 5, y = 6;
        int[][] obstacles = new int[][]{{2, 5}, {3, 6}, {5, 6}, {7, 10}, {6, 2}};

        int n = 11; // n要大于坐标可取值的上界
        HashSet<Integer> set = new HashSet<>();
        for (int[] arr : obstacles) {
            set.add(arr[0] * n + arr[1]);
        }
        System.out.println(set.contains(x * n + y));
    }
}
```
`set.add(arr[0] * n + arr[1]);`相当于把一个点(x, y)以11进制表示(要求题目涉及的点的坐标<11)，对任意点(x, y)，x * n + y的值唯一确定，而通过不断%n，可以确定n进制表示下的每一位，不会存在(x1, y1) != (x2, y2)，使得x1 * n + y1 == x2 * n + y2。从而可以把点和一个数对应起来。


### 在LeetCode874. 模拟行走机器人中遇到了一个问题，若点的坐标可以取负数怎么办？
此时n要取更大才行。对于-3 * 10^4 <= xi, yi <= 3 * 10^4，n要多大才能使得任意(x1, y1) != (x2, y2)，有x1 * n + y1 != x2 * n + y2 ？

只要n使得(x1 - x2) * n + (y1 - y2)必不为0即可。

    1. 若x1 - x2 == 0，则(x1 - x2) * n + (y1 - y2)不为0
    2. 若x1 - x2 != 0，因为(x1 - x2) * n + (y1 - y2) == 0 <=> n = (y2 - y1)/(x1 - x2)，则n只需取超过(y2 - y1)/(x1 - x2)的最大值6 * 10^4即可
        

### 再进一步，若是n维空间的点(a1, a2, ... , an)，此时应该取多少进制？
为与an的n区分，此时进制数用d表示。则问题为：

要取d使得任意(a1, a2, ... , an) != (b1, b2, ... , bn)，有an * $d^{n - 1}$ + ... a1 * $d^0$ != bn * $d^{n - 1}$ + ... b1 * $d^0$，即(an - bn) * $d^{n - 1}$ + ... + (a1 - b1) = 0无法成立;

设每个坐标ai范围为[-M, M]。

设(an - bn) * $d^{n - 1}$ + ... + (a1 - b1)中第一项不为0的为(ai - bi) * $d^{i - 1}$，不妨设其为正(否则两边取相反数即可)，则(ai - bi) >= 1。则后面的项的最小值为-2M($d^{i - 2}$ + $d^{i - 3}$ + ... + $d^0$) = -2M($d^{i - 1}$ - 1) / (d - 1)，则只需满足1 * $d^{i - 1}$ > 2M($d^{i - 1}$ - 1) / (d - 1)即可，即d只需满足:

$d^{i - 1}$ * (d - 1) / ($d^{i - 1}$ - 1) > 2M。

即可。

由于 $d^{i - 1}$ / ($d^{i - 1}$ - 1) > 1，则只需d - 1 >= 2M即可。

综上，设每个坐标ai范围为[-M, M]，则只需取d使得`d - 1 >= 2M`即可。

补充: 又想了下这个，之前想复杂了，只需考虑把$a_i$平移即可，对于$a_i$范围为[-M, M]，将$a_i$加上M平移到[0, 2M]，用进制表示法表示出($a_1$, $a_2$, ..., $a_n$)和用进制表示法表示出($a_1$ + M, $a_2$ + M, ..., $a_n$ + M)是等价的，于是只需取`d >= 2M + 1`即可，这样都化为非负在拆各个位的数时也方便。