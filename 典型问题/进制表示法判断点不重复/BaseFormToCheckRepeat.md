### 给定障碍点数组obstacles，对于点(x, y)，如何判断(x, y)是否为障碍点？（涉及的点的横纵坐标都>=0）
直接的做法是对每个障碍点构造一个Point对象，重写Point类的equals()和hashCode()方法，然后将障碍点放入HashSet中，然后判断set是否包含new Point(x, y)。但是若点的取值范围有限，可以不用创建Point对象：
```Java
public class BaseFormToCheckRepeat {
    public static void main(String[] args) {
        int x = 5, y = 6;
        int[][] obstacles = new int[][]{{2, 5}, {3, 6}, {5, 6}, {7, 10}, {6, 2}};

        int n = 11; // n要大于坐标可取值的上界
        HashSet<Integer> set = new HashSet<>();
        for (int[] arr : obstacles) {
            set.add(arr[0] * n + arr[1]);
        }
        System.out.println(set.contains(x * n + y));
    }
}
```
`set.add(arr[0] * n + arr[1]);`相当于把一个点(x, y)以11进制表示(要求题目涉及的点的坐标<11)，对任意点(x, y)，x * n + y的值唯一确定，而通过不断%n，可以确定n进制表示下的每一位，不会存在(x1, y1) != (x2, y2)，使得x1 * n + y1 == x2 * n + y2。从而可以把点和一个数对应起来。


### 在LeetCode874. 模拟行走机器人中遇到了一个问题，若点的坐标可以取负数怎么办？
此时n要取更大才行。对于-3 * 10^4 <= xi, yi <= 3 * 10^4，n要多大才能使得任意(x1, y1) != (x2, y2)，有x1 * n + y1 != x2 * n + y2 ？

只要n使得(x1 - x2) * n + (y1 - y2)必不为0即可。

    1. 若x1 - x2 == 0，则(x1 - x2) * n + (y1 - y2)不为0
    2. 若x1 - x2 != 0，因为(x1 - x2) * n + (y1 - y2) == 0 <=> n = (y2 - y1)/(x1 - x2)，则n只需取超过(y2 - y1)/(x1 - x2)的最大值6 * 10^4即可
        

### 再进一步，若是n维空间的点(a1, a2, ... , an)，此时应该取多少进制？
为与an的n区分，此时进制数用d表示。则问题为：

要取d使得任意(a1, a2, ... , an) != (b1, b2, ... , bn)，有an * $d^{n - 1}$ + ... a1 * $d^0$ != bn * $d^{n - 1}$ + ... b1 * $d^0$，即(an - bn) * $d^{n - 1}$ + ... + (a1 - b1) = 0无法成立;

设每个坐标ai范围为[-M, M]。

设(an - bn) * $d^{n - 1}$ + ... + (a1 - b1)中第一项不为0的为(ai - bi) * $d^{i - 1}$，不妨设其为正(否则两边取相反数即可)，则(ai - bi) >= 1。则后面的项的最小值为-2M($d^{i - 2}$ + $d^{i - 3}$ + ... + $d^0$) = -2M($d^{i - 1}$ - 1) / (d - 1)，则只需满足1 * $d^{i - 1}$ > 2M($d^{i - 1}$ - 1) / (d - 1)即可，即d只需满足:

$d^{i - 1}$ * (d - 1) / ($d^{i - 1}$ - 1) > 2M。

即可。

由于 $d^{i - 1}$ / ($d^{i - 1}$ - 1) > 1，则只需d - 1 >= 2M即可。

综上，设每个坐标ai范围为[-M, M]，则只需取d使得`d - 1 >= 2M`即可。

补充: 又想了下这个，之前想复杂了，只需考虑把$a_i$平移即可，对于$a_i$范围为[-M, M]（**可以为负**，以下用**可负进制表示**称呼），将$a_i$加上M平移到[0, 2M]，用可负进制表示法压缩$(a_1, a_2, ..., a_n)$和用进制表示法压缩$(a_1 + M, a_2 + M, ..., a_n + M)$是等价的，于是只需取`d >= 2M + 1`即可，这样不同$(a_1, a_2, ..., a_n)$算出来的值一定不同。

具体来说，当选定了d为>= 2M + 1的一个数后(以下以d = 2M + 1为例)，对于($a_1$, $a_2$, ..., $a_n$)，其中$a_i \in [-M, M]$，能求出其对应的值。为什么这种可负进制表示和值一一对应？

对于给定的可负进制表示，其值是确定的，计算即可得到，也就是说一个可负进制表示只有一个值。对于给定的值，其可负进制表示也一定唯一，否则，若有两个可负进制表示，将较短者高位补0对齐后，按上述平移的处理可以得到两个$2M+1$进制表示（这里是通常意义下的$0<= a_i < d$的进制表示了），且两个平移对值的增长量相同，也就是说对同一个值有两个进制表示，矛盾。

对于给定进制，数的值和数的进制表示是一一对应的(根据进制表示可以直接算出值，根据值能通过不断取余求商求出进制表示)。

根据上面的讨论，可负进制表示与值也是一一对应的，那么，如何根据值求出对应的可负进制表示？

如果能确定值对应的可负进制表示的有效位数，则可以加上$M * d^0 + M * d^1 + ... + M * d^i$转换为普通的$2M+1$进制表示下的值，然后通过普通值计算进制表示，然后每位减去M即可求出值对应的可负进制表示。

如何确定值对应的可负进制表示的有效位数？

$-M * d^0 + -M * d^1 + ... + -M * d^i = -M \frac {d^{i+1} - 1}{d - 1}$，而$d = 2M + 1$，故$-M * d^0 + -M * d^1 + ... + -M * d^i = -\frac{d^{i+1}-1}{2}$

也就是说，对于i+1位的可负进制表示，其范围为$[-\frac{d^{i+1}-1}{2}, \frac{d^{i+1}-1}{2}]$，则可以枚举有效位数0, 1, 2...(如果知道有效位数上限还可以二分查找，或者直接按有效位数为上限处理，最后高位会为0)，然后判定值是否在相应范围求得有效位数。

求值对应的进制表示有一个直接的过程，但是这里求值对应的可负进制表示(也就是从压缩后的值里拆位)，我没想到一个不用先求有效位数，然后转为普通进制表示下的值的办法。主要每位可能为负，直接不断取余求商行不通。

总的来说，如果只是要判定向量($a_1$, $a_2$, ..., $a_n$)，其中$a_i \in [-M, M]$是否重复，则可以将向量压缩为值$a_1 * d^{n-1} + a_2 * d^{n-2} + ... + a_n *d^0$，但是这不方便拆位。如果还有从值拆位恢复的需求的话，最好把向量处理为$(a_1 + M, a_2 + M, ..., a_n + M)$，然后用普通的进制表示法，压缩时用这个向量算值，解压时求余拆位之后要减M才能获得原本的位。