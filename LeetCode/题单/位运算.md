# 位运算基础

灵神总结的位运算基础技巧：[从集合论到位运算，常见位运算技巧分类总结](https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/)

# 位运算优先级较低
注意位运算[优先级](https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170#c-operator-precedence-and-associativity-table)比较低，位运算的部分记得打括号。具体见 典型问题/C++的一些坑 。

# 异或

## 异或的性质
对于异或，`0`是其单位元，一个数的逆元是其本身，XOR `1` 的效果是取反。

* [LeetCode1486. 数组异或操作](https://leetcode.cn/problems/xor-operation-in-an-array/) (4k ^ 4k + 1 ^ 4k+ 2 ^ 4k + 3 = 1 ^ 1 = 0)

* [LeetCode1720. 解码异或后的数组](https://leetcode.cn/problems/decode-xored-array/)

* [LeetCode2433. 找出前缀异或的原始数组](https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/)

* [LeetCode1310. 子数组异或查询](https://leetcode.cn/problems/xor-queries-of-a-subarray/) (异或的前缀和，LeetCode1486也用到了)

* [LeetCode2683. 相邻值的按位异或](https://leetcode.cn/problems/neighboring-bitwise-xor/) (类似LeetCode2433)

* [LeetCode1442. 形成两个异或相等数组的三元组数目](https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/) (可以用异或的前缀和，有更优解法)

* [LeetCode2429. 最小异或](https://leetcode.cn/problems/minimize-xor/) (翻转最低位的0/1)
    
    把最低位的 1 变成 0：`x &= x - 1;`

    把最低位的 0 变成 1：`x |= x + 1;`

    把最高位的 1 变成 0：`x &= ~(1 << (bit_width(x) - 1));`

* [LeetCode2588. 统计美丽子数组数目](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/) (异或的前缀和 + 哈希表计数)

* [LeetCode2564. 子字符串异或查询](https://leetcode.cn/problems/substring-xor-queries/) (看似 KMP ，实则枚举长度)

* [LeetCode1734. 解码异或后的排列](https://leetcode.cn/problems/decode-xored-permutation/) (LeetCode1720，LeetCode2683 的进阶版)

## 拆位
由于位运算每个比特位互不相干，所以拆分成每个比特位分别计算。

* [LeetCode2527. 查询数组异或美丽值](https://leetcode.cn/problems/find-xor-beauty-of-array/)

* [LeetCode2317. 操作后的最大异或和](https://leetcode.cn/problems/maximum-xor-after-operations/)

## 字典树

* [LeetCode1803. 统计异或值在范围内的数对有多少](https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/) (借助字典树统计异或方案数，在节点上记录子树叶节点数有点像线段树的懒惰标记)

# 与或（AND/OR）
## AND的性质
* [LeetCode2419. 按位与最大的最长子数组](https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/)

* [LeetCode2871. 将数组分割成最多数目的子数组](https://leetcode.cn/problems/split-array-into-maximum-number-of-subarrays/)

## OR的性质
* [LeetCode2680. 最大或值](https://leetcode.cn/problems/maximum-or/)

AND 和 OR ，不像 XOR 一样有逆元。比如 `01 & 00 == 10 & 00 == 00`，`01 | 11 == 10 | 11 == 11`。但是LeetCode2680的[灵茶题解](https://leetcode.cn/problems/maximum-or/solutions/2268795/tan-xin-qian-hou-zhui-fen-jie-pythonjava-wrv1/)中有一种办法，可以从一堆数的 OR 中摘出来某个数（使用了 XOR 和修复手段，效果上像是找到了 OR 的逆元）

AND 的单位元是`1`，零元是`0`

OR 的单位元是`0`，零元是`1`
