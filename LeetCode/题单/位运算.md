# 位运算基础

灵神总结的位运算基础技巧：[从集合论到位运算，常见位运算技巧分类总结](https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/)

# 位运算优先级较低
注意位运算[优先级](https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170#c-operator-precedence-and-associativity-table)比较低，位运算的部分记得打括号。具体见 典型问题/C++的一些坑 。

# 异或

## 异或的性质
对于异或，0是其单位元，一个数的逆元是其本身。

* [LeetCode1486. 数组异或操作](https://leetcode.cn/problems/xor-operation-in-an-array/) (4k ^ 4k + 1 ^ 4k+ 2 ^ 4k + 3 = 1 ^ 1 = 0)

* [LeetCode1720. 解码异或后的数组](https://leetcode.cn/problems/decode-xored-array/)

* [LeetCode2433. 找出前缀异或的原始数组](https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/)

* [LeetCode1310. 子数组异或查询](https://leetcode.cn/problems/xor-queries-of-a-subarray/) (异或的前缀和，LeetCode1486也用到了)

* [LeetCode2683. 相邻值的按位异或](https://leetcode.cn/problems/neighboring-bitwise-xor/) (类似LeetCode2433)

* [LeetCode1442. 形成两个异或相等数组的三元组数目](https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/) (可以用异或的前缀和，有更优解法)

* [LeetCode2429. 最小异或](https://leetcode.cn/problems/minimize-xor/) (翻转最低位的0/1)
    
    把最低位的 1 变成 0：`x &= x - 1;`

    把最低位的 0 变成 1：`x |= x + 1;`

    把最高位的 1 变成 0：`x &= ~(1 << (bit_width(x) - 1));`

* [LeetCode2588. 统计美丽子数组数目](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/) (异或的前缀和 + 哈希表计数)

* [LeetCode2564. 子字符串异或查询](https://leetcode.cn/problems/substring-xor-queries/) (看似 KMP ，实则枚举长度)

* [LeetCode1734. 解码异或后的排列](https://leetcode.cn/problems/decode-xored-permutation/) (LeetCode1720，LeetCode2683 的进阶版)

## 拆位
由于位运算每个比特位互不相干，所以拆分成每个比特位分别计算。

* [LeetCode2527. 查询数组异或美丽值](https://leetcode.cn/problems/find-xor-beauty-of-array/)

* [LeetCode2317. 操作后的最大异或和](https://leetcode.cn/problems/maximum-xor-after-operations/)