# dfs

## dfs vis的修改位置问题

* 以[LeetCode547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)为例 (dfs求无向图连通分量数)

尝试对每个点做一次dfs，如果尝试对一个点做dfs时，此点为!visited状态，则发现了一个连通分量。

注意对访问状态的判断，尝试对每个点做一次dfs时，如果!vis[i]，才进dfs()，所以保障了dfs的根是未访问的。

### 写法1 (标准写法)

最标准的写法，保障开启的每个dfs()实例，根都是未访问的，每个dfs()实例**自己标记且只标记自己的根，对未访问的邻居递归**：

```cpp
// LeetCode547，graph为邻接矩阵
int n = graph.size();
int ans = 0;
vector<int> vis(n);

auto dfs = [&](auto &dfs, int r) -> void {
    vis[r] = true; // 标记自己
    for (int next = 0; next < n; next++) {
        if (graph[r][next] && next != r && !vis[next]) { // !vis[next]才递归，这里可以不写 next != r 的判断
            dfs(dfs, next);
        }
    }
};


for (int i = 0; i < n; i++) {
    if (!vis[i]) { // 这里保证了每个dfs分量的起点是未访问的
        ans++;
        dfs(dfs, i);
    }
}

return ans;
```

注意上面写法是不需要在dfs()开头写`if (vis[r]) return;`的（虽然对上面写法，写了也不会错，但是无意义，r 一定是未访问的）。`vis`是在递归邻居时发挥作用用来判断的，记住不要忘了判断vis (`if (!vis[next]) dfs(dfs, next);`)。

### 写法2 (不要写这种写法)：

一个dfs()实例可以也把自己的邻居标记为visited，这种写法也可以。但是注意必不能在dfs()开头写`if (vis[r]) return;`。否则会导致：u将自己的未访问邻居v标记为已访问，紧接着dfs(v)时没访问直接返回了。这种写法在两个地方都在标记，虽然能work，但是dfs(u)时标记v，紧接着dfs(v)又标记v，重复标记了。不要写这种写法，`vis[next] = true;`是完全多余的，删去这行就是写法1了。

```cpp
// 不推荐的写法
auto dfs = [&](auto &dfs, int r) -> void {
    // 不能在这里写 if (vis[r]) return;
    vis[r] = true; // 标记自己
    for (int next = 0; next < n; next++) {
        if (graph[r][next] && next != r && !vis[next]) {
            vis[next] = true; // 把邻居也给标记了
            dfs(dfs, next);
        }
    }
};
```
不要写出既标记自己，也标记邻居，就能避免这种写法了。

### 写法3（性能非最佳，dfs()调用次数偏多）

总是开启dfs，多走一层，靠dfs()开头判断。dfs()调用次数偏多。

```cpp
auto dfs = [&](auto &dfs, int r) -> void {
    if (vis[r]) return; // 这里进行了判断
    vis[r] = true;
    for (int next = 0; next < n; next++) {
        if (graph[r][next] && next != r) { // 这种写法不判断 !vis[next]，直接进递归，靠递归开头判断
            dfs(dfs, next);
        }
    }
};
```

这种写法，加上`if (!vis[next])`的判断，再删去这样之后会变成无意义的`if (vis[r]) return;`，就是写法1了。

但是如果是另外一些dfs问题，例如线段树的继续递归判断，这种写法将非法情况在下一层进行辨别，代码会简短一点。要递归时判断合法：`if (L <= m) dfs(...); if (R > m) dfs(...);` 和 入口检查非法情况：`if(R < s || L > t) return;`的区别。

（`不引入非法状态` 与 `筛除非法状态`）

### 写法4 (类bfs)

类bfs，bfs在入队时标记。这种写法在要进dfs()前标记，注意标记必须写在dfs()调用之前，否则会重复访问，甚至死循环。

```cpp
auto dfs = [&](auto &dfs, int r) -> void {
    for (int next = 0; next < n; next++) {
        if (graph[r][next] && next != r && !vis[next]) {
            vis[next] = true; // dfs()之前标记，与bfs不同，必须写在dfs()前面
            dfs(dfs, next);
        }
    }
};


for (int i = 0; i < n; i++) {
    if (!vis[i]) { // 这里保证了每个dfs分量的起点是未访问的
        ans++;
        vis[i] = true; // dfs()之前标记，与bfs不同，必须写在dfs()前面
        dfs(dfs, i);
    }
}

return ans;
```

写法4与写法1是等价的，区别仅仅在于： `在紧接着就要进dfs()的前一刻标记r` 还是 `在dfs()的第一行标记r`。

其它例题：

* [LeetCode841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)

## 用特异值表示visited状态
小技巧：如果要做多轮完全独立的dfs，而每轮dfs有个特异值相关联，可以用那个特异值判断visited状态，不用每轮开始时重新初始化一遍vis数组。别忘了vis头一次初始化时也要是个特异值。

```cpp
vector<int> vis(n, -1); // 初始化为一个和所有轮的特异值都不同的值

dfs(root, turn) {
    vis[root] = turn; // 相当于 vis[root] = true;
    ...
    if (vis[neighbor] != turn) dfs(neighbor); // vis[neighbor] != turn 相当于 !vis[neighbor]
}
```
* [LeetCode2192. 有向无环图中一个节点的所有祖先](https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/) (求一个节点的所有祖先)

* [LeetCode3048. 标记所有下标的最早秒数 I](https://leetcode.cn/problems/earliest-second-to-mark-indices-i/)

* [LeetCode3419. 图的最大边权的最小值](https://leetcode.cn/problems/minimize-the-maximum-edge-weight-of-graph/)

## 平面点之间的可达性
* [LeetCode2101. 引爆最多的炸弹](https://leetcode.cn/problems/detonate-the-maximum-bombs/) (Floyd算法 + bitset优化)

## 三色标记法

* [LeetCode207. 课程表](https://leetcode.cn/problems/course-schedule/) (三色标记法 / 拓扑排序)

* [LeetCode802. 找到最终的安全状态](https://leetcode.cn/problems/find-eventual-safe-states/) (三色标记法变式 / 反图拓扑排序)

## 并查集拆分

* [LeetCode2092. 找出知晓秘密的所有专家](https://leetcode.cn/problems/find-all-people-with-secret/)

    这题特殊，并查集各个连通分量的节点混在一起后，此题的操作特性，(如果需要拆的话)一个连通分量一定全拆，一定会将其节点全部独立，所以能给并查集增加一个 isolate(int x) 的接口。并查集并不适合拆分的操作。