# 启发式搜索

[deepseek](https://chat.deepseek.com/)对启发式搜索思想的解释：

启发式搜索（Heuristic Search）是一种在搜索过程中利用启发式信息（heuristic information）来引导搜索方向，从而更快地找到目标的方法。它通常用于解决状态空间很大的问题，比如路径规划、游戏AI、人工智能规划等。

### 核心思想
- **启发式函数（Heuristic Function）**：通常记作 h(n)，它是一个从当前状态到目标状态的代价估计函数。这个函数提供了从当前状态到目标状态的“最佳猜测”代价。例如，在路径规划中，h(n) 可以是当前点到终点的直线距离（欧几里得距离）或曼哈顿距离。
- **目的**：通过启发式函数来优先探索那些看起来更有希望到达目标的路径，从而减少搜索的节点数，提高搜索效率。

### 常见算法
1. **贪心最佳优先搜索（Greedy Best-First Search）**：
   - 完全依赖启发式函数：总是选择 h(n) 最小的节点进行扩展。
   - 优点：速度快。
   - 缺点：可能陷入局部最优，且不一定能找到最优解。
2. **A\* 搜索（A-Star Search）**：
   - 结合了从起点到当前节点的实际代价 g(n) 和启发式函数 h(n)。
   - 评估函数为：f(n)=g(n)+h(n)。
   - 总是选择 f(n) 最小的节点进行扩展。

### 关键概念
- **可接受性（Admissibility）**：启发式函数 h(n) 是可接受的，当且仅当对于所有节点 n，有 h(n)≤h∗(n)，其中 h∗(n) 是从 n 到目标状态的实际最小代价。例如，曼哈顿距离在网格路径问题中是可接受的（因为它忽略了障碍物，实际代价通常更大）。
- **一致性（Consistency）**：也称为单调性。要求对于任意节点 n 和其邻居节点 n′，满足 h(n)≤c(n,n′)+h(n′)，其中 c(n,n′) 是从 n 到 n′ 的实际代价。曼哈顿距离在网格路径问题中是一致的。

---

启发式搜索是一种思想，优先尝试当前预估最可能得到最优解的方向，并在行动过程中不断更新信息。

要求最短距离，启发函数$h$必须满足**可接受性**。

此外：[参考](https://www.cnblogs.com/ISGuXing/p/9800490.html)，启发函数要 >= 0：

1. h(x) >= 0

2. h(x)越小表示 x 越接近目标点

3. 如果 h(x) == 0 ，说明到达目标点

# A* 算法
A* 算法用于求**单源单目标最短距离**。

A* 算法的典型应用场景即为网格路径问题：一个网格图(每个点都可以用坐标描述)，其中有一些点为障碍物不能走，求给定起点到给定终点的最短距离。（从起点到终点，避开障碍物）

[oiwiki](https://oi-wiki.org/search/astar/)对A*算法的解释：

定义起点 $s$，终点 $t$，从起点（初始状态）开始的距离函数 $g(x)$，到终点（最终状态）的距离函数 $h(x)$，$h^{\ast}(x)$，以及每个点的估价函数 $f(x)=g(x)+h(x)$。

A \* 算法每次从优先队列中取出一个 $f$ 最小的元素，然后更新相邻的状态。

如果 $h\leq h*$，则 A \* 算法能找到最优解。

上述条件下，如果 $h$ 满足三角形不等式，则 A \* 算法不会将重复结点加入队列（存疑，见[A*的出入队次数](#入队出队次数)）。

当 $h=0$ 时，A \* 算法变为 Dijkstra；当 $h=0$ 并且边权为 $1$ 时变为 BFS。

## A* 算法的思想

A* 算法用于求**单源单目标最短距离**，只能用于**给定起点**和**给定终点**，求最短距离的情况，不能求一个点到所有其它点的最短距离。而Dijkstra算法用于求**单源多目标最短距离**。

A* 算法的思想大概是这样，例如一个 100 * 100 的网格图，其中有一些障碍点不能走，求(20, 30)到(30, 50)的最短距离。

若使用Dijkstra算法，则其会往上面也扩展一大片。如果网格图极大甚至无限大，Dijkstra算法会浪费大量时间。

但是，我们能猜到大概率最短路径是往右下走，我们应当优先做此方向的行走尝试。(19, 30)这样的点入队，然后(18, 30)、(18, 29)、(18, 31)入队应当放到后面来做。怎么办？

修改节点优先级的逻辑，加上预估距离。例如，我们预估(20, 30)到(30, 50)的距离为最短可能距离30，然后到了(21, 30)这个点，其实际已经走了距离1，加上预估距离29，只要(21, 30)处并非障碍，那么就可以继续从(21, 30)开始行动，而(19, 30)的出队就被延迟到了以后（其并未被放弃，仍然是入队了的，但是由于预估距离大，前面更有潜力的选择走不通时才会出队并向队列中引入自己的邻居，这就是A* 算法的**启发性**所在）。

既然预估小，则接着这个点走，这个点走一步后，入队自己的邻居，这些邻居与优先队列中的点重新比较，又选出 f 最小的来走。

优先队列节点的优先级 $f$ 包括两个部分：
1. 起点到当前节点的实际距离 $g$ (不一定是最短距离，就是当前路径的距离)，这是确切的，在行走中记录了下来
2. 当前节点到终点的预估距离 $h$，这是用启发函数估计的

$f = g + h$ 为**节点最新的估计距离**，以 $f$ 作为优先级来选择出队的节点。

也就是说，A* 算法以**全局估计最小距离**作为优先级，Dijkstra 算法以**局部已知最小距离**作为优先级。

也就是说，A* 算法引入了倾向性，在bfs的基础上混入了指向目标节点的dfs。

## A* 算法bfs优先
考虑这样一种场景，100 * 100 的矩阵，从(0, 50)走到(100, 50)，理论最短距离为竖线99，如果走这条竖线走到中间(50, 50)遇到个障碍，那么其会绕过这个障碍继续dfs吗？否，这时会轮到所有估计距离为101的点都作为一个批次出队，例如(0, 49) ~ (49, 49)、(0, 51) ~ (49, 51)等。

也就是说，行走会优先变粗(bfs)，而非优先变长(dfs)。如果不这样的话，优先dfs走到后面发现不行就不知道怎么回退尝试别的路了。A*算法不会想着“毕其功于一役”，而是会“先集满最小f层，稳步齐进”

## A* 算法的正确性

**只要启发函数$h$具有可接受性$h\leq h*$，A\* 算法就是正确的（无需一致性）。**

**终点第一次出队时，算法即结束，报告最短距离。** Dijkstra算法如果只关心一个终点的话，也可以终点第一次出队时就结束算法，**终点第一次出队时即为到终点的最短距离**。见 LeetCode2290 minimumObstacles()

$f = g + h$，虽然有估计的成分 $h$，但是整个过程中是 $g$ 在增大，$h$ 在缩小，直到到终点时 $h$ 变为0，所以虽然过程中有估计的成分，但是最后估计的成分被清掉了，距离是准确的。估计成分是在中途用来做抉择的。

我们每次都贪心地选择了估计距离最小的节点出队，而由于$h\leq h*$，并且算法结束时估计的成分被清除了，那么终点出队时的那个 $f$ 就是一个到终点的实际距离，也是最小的到终点的实际距离。(还有一些实际距离，但那些不是最短路径，留在了优先队列中，无需计算)

$f = g + h$，$f* = g* + h*$，$g$始终为实际的$g*$，出队时$h == h* == 0$，所以出队时$f$是个实际的$f*$。由于优先队列，也是终点最小的$f*$，于是就是最小距离。

## A* 算法的一致性
当一个节点出队并引入自己的邻居时，其是在以起点到自己的实际距离 $g$ 在操作，将实际距离 $g$ 传给了邻居，然后它们自己去估计自己的距离。这个出队是妥当的，不会漏掉什么。

但是这并不代表这个节点不会重新入队。当某个节点的最短距离被更新得更小，是要让其重新入队的。如果启发函数$h$不满足三角不等式，就可能发生这种情况。

如果$h$满足三角不等式，为什么一个节点不会重新入队？

考虑节点z，其第一次入队被x拉入，那么后续其还会被另外一个节点y拉入吗？

否，x y z构成一个三角形XYZ或在一条直线上，XZ <= XY + YZ，y不需要让z重新入队。

## 启发函数$h$的选择
参考[LeetCode675宫水三叶题解](https://leetcode.cn/problems/cut-off-trees-for-golf-event/solutions/1512294/by-ac_oier-ksth/)和[路径规划之 A* 算法](https://zhuanlan.zhihu.com/p/54510444)：

**我们往往会直接使用「理论最小步数」来作为启发式函数。**

* 如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离

* 如果图形中允许朝任何方向移动，则可以使用欧几里得距离

## A* 算法的时间复杂度

LeetCode675宫水三叶题解和官方题解都是这样解释A*算法的时间复杂度的：**启发式搜索不讨论时空复杂度。**

不过应该还是能分析一下的，和启发函数有关：

如果启发函数满足可接受性不满足一致性，一个节点可能多次入队，可能达到指数级。这个很像边权可能为负的优先队列Dijkstra，有负权环的话应该还能死循环，不过一般A*算法的场景要求h >= 0，也就是说不会出现负权边。

如果启发函数满足可接受性和一致性，应该和优先队列Dijkstra一样是 $O(eloge)$。具体运行时间得看输入，有可能直接一路就找到最短路径了。

### 入队出队次数
A* 算法，如果启发函数满足三角不等式，那么一个节点是：1. 出队后不会再需要重新入队。还是: 2. 不会多次入队？

[oiwiki](https://oi-wiki.org/search/astar/)上说的是后者，但我觉得是前者。
```
x   y
 \ /
  z
```
如果x先拉z入队，有f1(z) = g(x) + c(x, z) + h(z)；

y让z入队时，有f2(z) = g(y) + c(y, z) + h(z)。

有可能f2(z)更小，z要再次入队。

我理解三角不等式是这样用的：

$f(n') = g(n') + h(n')
       = g(n) + c(n, n') + h(n')
       >= g(n) + h(n)
       = f(n)$

也就是说一条探索路径上前后两个点n n' (n在前 n'在后)，f一定单增，这就有Dijkstra边权非负的感觉了，z出队后，后续的节点如果想拉z，那么其f大于当前记录的最短f(z)，再加条边只会更大，所以z出队一次后一定不再需要重新入队，所以是前者。

[LeetCode675. 为高尔夫比赛砍树](https://leetcode.cn/problems/cut-off-trees-for-golf-event/)的代码，加上入队时打印节点，能看到一个节点会多次入队。可能和问题性质有关，这个[A*算法 八数码](https://www.bilibili.com/video/BV1xk4y1u7yg/)里面八数码的代码，里面就直接写的if (!d.count(t))，这里这个t是状态，已经搜索过了后面不用重新搜索一次，这样就只会入队一次。

回到网格路径问题上来，类似优先队列Dijkstra算法里的`if (distance > dis[node]) continue;`剪枝手段是怎样的？

见[./solution675_implementation3.cpp](./solution675_implementation3.cpp)的代码：

用一个dis数组记录各个节点目前遇到的最短g。当发现一个节点之前以更小的g开始搜索过，那么就不需要以当前的g开始搜索，直接剪掉。由于一个节点的f - g为h(定值)，存当前遇到过的最小g来剪枝，和存当前遇到过的最小f来剪枝是一样的。用g要好理解一点。

# 参考

* [LeetCode675宫水三叶题解](https://leetcode.cn/problems/cut-off-trees-for-golf-event/solutions/1512294/by-ac_oier-ksth/)

* [路径规划之 A* 算法](https://zhuanlan.zhihu.com/p/54510444)

* [启发式搜索（heuristic search）———A*算法](https://www.cnblogs.com/ISGuXing/p/9800490.html)

* [oiwiki](https://oi-wiki.org/search/astar/)